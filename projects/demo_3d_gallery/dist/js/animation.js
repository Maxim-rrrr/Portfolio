function ln(t,e){return 0===t?0:Math.log(e/t)}function line(){return 1}function lineUp(t){return t}function lineDown(t,e){return-t+e}function createTickSpeeds(t,e,i,n){let s,a=0,r=[],o=0;switch(i){case"line":s=line;break;case"ln":s=ln;break;case"lineUp":s=lineUp;break;case"lineDown":s=lineDown;break;case"custom":s=n}for(;o<t*(e/1e3);){let i=s(o*(1e3/e),t);a+=i,r.push(i),o++}return r.map(t=>t/a)}export class Animation{constructor(t){this.target=t,this.actions=[]}to(t,e,i=50,n="line",s=(()=>{})){return this.actions.push({type:"animation",values:t,time:e,FPS:i,mode:n,speeds:createTickSpeeds(e,i,n,s)}),this}wait(t){return this.actions.push({type:"wait",time:t}),this}call(t){return this.callback=t,this}start(){return this.actions.forEach((t,e)=>{let i=0;for(let t=0;t<e;t++)i+=this.actions[t].time;let n=e===this.actions.length-1&&!!this.callback;"animation"===t.type&&setTimeout(()=>{let e=0;const i=setInterval(()=>{for(const[i,n]of Object.entries(t.values))this.target[i]+=n*t.speeds[e];++e===t.speeds.length&&(clearInterval(i),n&&this.callback())},1e3/t.FPS)},i)}),this}reverse(){const t=new Animation(this.target);return this.actions.forEach(e=>{if("animation"===e.type){let i=Object.assign({},e.values);for(let t in i)i[t]=-i[t];t.to(i,e.time,e.FPS,e.mode,e.customAnimationFunc)}else"wait"===e.type&&t.wait(e.time)}),t}}export class AnimationMix{constructor(){this.animations=Object.values(arguments)}start(){this.animations.forEach(t=>{t.start()})}reverse(){return new AnimationMix(...this.animations.map(t=>t.reverse()))}}